#include <iostream>
#include <fstream>
#include <set>
#include "pin.H"

using std::cout;
using std::cerr;
using std::ofstream;
using std::ios;
using std::string;
using std::endl;

typedef struct StackFrame {
    ADDRINT retAddr;
    struct StackFrame *fd;
} StackFrame;

#define chunksize(p) ((*(ADDRINT*)((p)-8)) & ~7)
#define chunksize_user(p) ((chunksize(p))-16)

KNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool", "o", "seg.out", "specify output file name");
KNOB<BOOL>   KnobDebug(KNOB_MODE_WRITEONCE, "pintool", "v", "0", "verbose output");

ofstream OutFile;
BOOL debug;

string invalid = "invalid_rtn";
int inuseLabel;
int freeLabel;
StackFrame callStack;

VOID Push(ADDRINT addr){
    StackFrame *head = &callStack;
    StackFrame *fd = head->fd;
    StackFrame *newFrame = (StackFrame*)(malloc(sizeof(StackFrame)));

    newFrame->retAddr = addr;
    newFrame->fd = fd;
    head->fd = newFrame;
    if(debug) OutFile << "push " << addr << endl;
}

ADDRINT Pop(){
    StackFrame *head = &callStack;
    StackFrame *fd = head->fd;
    
    if (head==fd) {
        cout << "exit in pop, lack of frames" << endl;
        exit(1);
    }
    ADDRINT ret = head->fd->retAddr;
    head->fd = fd->fd;
    free(fd);

    return ret;
}

const string *Target2String(ADDRINT target)
{
    string name = RTN_FindNameByAddress(target);
    if (name == "")
        return &invalid;
    else
        return new string(name);
}

VOID Ret(ADDRINT address)
{
    if (debug) OutFile << "RET " << address << endl;
    if(Pop()!=address){
        cout << "suspicious return address detected: aborting" << endl;
        exit(1);
    }
}

VOID Call(ADDRINT target, ADDRINT returnIp)
{
    if (debug) OutFile << "Call " << target << " Return: " << returnIp<< endl;
    Push(returnIp);
}

VOID MallocPre(ADDRINT rAllocSize, ADDRINT *wAllocSize, ADDRINT target, ADDRINT returnIp){
     if (debug) OutFile << "malloc pre " << rAllocSize << " 0x" << returnIp << endl;
     *wAllocSize = rAllocSize+16;
     Call(target, returnIp);
}

VOID MallocPost(ADDRINT chunkAddr, ADDRINT returnIp){
     if (debug) OutFile << "user size: " << chunksize_user(chunkAddr) << endl;
     if(chunkAddr!=0)
         *(ADDRINT*)(chunkAddr+chunksize_user(chunkAddr)-16)=(ADDRINT)(&inuseLabel);
}

VOID FreePre(ADDRINT chunkAddr, ADDRINT target, ADDRINT returnIp ){
     if (debug) OutFile << "freeing: " << chunkAddr << " (" << chunksize_user(chunkAddr) << ")" << endl;

     ADDRINT p = chunkAddr;
     ADDRINT *guardField = (ADDRINT*)(p+chunksize_user(p)-16);

     if (*guardField != (ADDRINT)(&inuseLabel)){
        if (*guardField == (ADDRINT)(&freeLabel)){
           cout << "double-free detected" << endl;
	   exit(1);
        } else {
           cout << "corrupted heap chunk detected" << endl;
	   exit(1);
        }
     } else {
        *guardField = (ADDRINT)(&freeLabel);
     }

     Call(target, returnIp);
}
    
VOID Instruction(INS ins, VOID *v)
{
    static std::set<ADDRINT> ms;
    ADDRINT currentAddr = INS_Address(ins);
    ADDRINT nextAddr = INS_NextAddress(ins);

    if (ms.find(INS_Address(ins))!=ms.end()){
           //asmOrFuncName = INS_Disassemble(ins);
           INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)MallocPost, IARG_REG_VALUE, REG_RAX, IARG_ADDRINT, nextAddr, IARG_END);
    }
    if(INS_IsCall(ins)){
        if (INS_IsDirectControlFlow(ins)){
		const ADDRINT target = INS_DirectControlFlowTargetAddress(ins);
		const string *targetName = Target2String(target);
                IMG img = IMG_FindByAddress(currentAddr);

		if((*targetName).compare("malloc@plt")==0  && IMG_Valid(img) && IMG_IsMainExecutable(img)){
		     ms.insert(nextAddr);
                     INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)MallocPre, 
                                         IARG_REG_VALUE, REG_EDI, 
                                         IARG_REG_REFERENCE, REG_EDI, 
                                         IARG_ADDRINT, target, 
                                         IARG_ADDRINT, nextAddr, IARG_END);
                } else if ((*targetName).compare("free@plt")==0  && IMG_Valid(img) && IMG_IsMainExecutable(img)) {
                     INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)FreePre, 
                                         IARG_REG_VALUE, REG_RDI, 
                                         IARG_ADDRINT, target, 
                                         IARG_ADDRINT, nextAddr, IARG_END);
                } else {
                     INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)Call, 
                                         IARG_ADDRINT, target, 
                                         IARG_ADDRINT, nextAddr, IARG_END);
                }
        } else {
		INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)Call, 
                                    IARG_BRANCH_TARGET_ADDR, 
                                    IARG_ADDRINT, nextAddr, IARG_END);
        }
    }
    if(INS_IsRet(ins)){
        INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)Ret, IARG_BRANCH_TARGET_ADDR, IARG_END);
    }
}

VOID Fini(INT32 code, VOID *v)
{
    OutFile.setf(ios::showbase);
    OutFile.close();
}

INT32 Usage()
{
    cerr << "Super Advanced Exploit Guard" << endl;
    cerr << endl << KNOB_BASE::StringKnobSummary() << endl;
    return -1;
}

int main(int argc, char * argv[])
{
    if (PIN_Init(argc, argv)) return Usage();
    PIN_InitSymbols();

    callStack.retAddr = 0;
    callStack.fd = &callStack;

    debug = KnobDebug.Value();

    OutFile.open(KnobOutputFile.Value().c_str());
    OutFile << std::hex;

    INS_AddInstrumentFunction(Instruction, 0);
    PIN_AddFiniFunction(Fini, 0);
    PIN_StartProgram();
    
    return 0;
}
